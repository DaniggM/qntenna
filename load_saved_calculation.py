'''
load_saved_calculation.py

version 1.1
last updated: March 2020

by Trevor Arp
Quantum Materials Optoelectronics Laboratory
Department of Physics and Astronomy
University of California, Riverside, USA

This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.

Description:
A script to load and display saved data generated by qntenna.py

See accompanying README.txt for instructions on using this code.
'''

from qntenna import find_optimum_peaks, load_calculation, gauss

from matplotlib.colorbar import ColorbarBase
import matplotlib.colors as colors
import matplotlib.cm as cm
from mpl_toolkits.axes_grid1.inset_locator import InsetPosition

import numpy as np
import matplotlib.pyplot as plt
import argparse

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    helpstr = "Path to directory of saved output files, by default search to local calculations directory"
    parser.add_argument("savefile", help=helpstr)
    parser.add_argument("-w", "--width", type=float, help="Absorber width to display, by default displays the maximum")
    parser.add_argument("-n", "--npeaks", type=float, help="Number of peaks to search for in the Delta parameter space")
    args = parser.parse_args()
    directory = args.savefile

    xinches = 5.3
    yinches = 7.75
    fig1 = plt.figure(directory+' Delta', figsize=(xinches, yinches), facecolor='w')

    width = 3.25
    xmargin = 1.0
    height = width
    ymargin = 0.5
    yint = 0.5

    ax1 = plt.axes([xmargin/xinches, (ymargin + height + yint)/yinches, width/xinches, height/yinches])
    ax2 = plt.axes([xmargin/xinches, ymargin/yinches, width/xinches, height/yinches])

    calc_data, spectrum = load_calculation(directory)
    [l0, dl, w, Delta] = calc_data

    if args.width is None:
        display_width = np.max(w)
    else:
        display_width = args.width

    if args.npeaks is None:
        npeaks = 2
    else:
        npeaks = int(args.npeaks)

    peak = find_optimum_peaks(l0, dl, w, Delta, npeaks)
    wi = np.searchsorted(w, display_width)

    print("Displaying w = " + str(w[wi]) + " nm")
    print("Calculated values of w:")
    print(list(w))

    cmap = plt.get_cmap('viridis')
    cnorm  = colors.Normalize(vmin=0.0, vmax=1.0)
    scalarMap = cm.ScalarMappable(norm=cnorm, cmap=cmap)
    scalarMap.set_array(Delta)

    d = Delta[:,:,wi]/np.max(Delta[:,:,wi]) # normalized data

    # np.flipud is used to get the vertical axis into the normal orientation
    ax1.imshow(np.flipud(d), cmap=cmap, norm=cnorm, extent=(np.min(l0), np.max(l0), np.min(dl), np.max(dl)), aspect='auto')
    for j in range(npeaks):
        ax1.plot(peak[j][wi,1], peak[j][wi,2], 'o', c='C'+str(j))

    ax1.set_ylabel(r'$\Delta \lambda$ (nm)')
    ax1.set_xlabel(r'$\lambda_{0}$ (nm)')
    ax1.set_title(r'$\Delta^{op}$ at w =' + str(w[wi]) + ' nm for ' + directory)

    axpbar = plt.axes([0, 0, 101, 101], zorder=2)
    axpbar.spines['bottom'].set_color('w')
    axpbar.spines['top'].set_color('w')
    axpbar.spines['left'].set_color('w')
    axpbar.spines['right'].set_color('w')
    axpbar.tick_params(axis='x', colors='w')
    axpbar.tick_params(axis='y', colors='w')
    axpbar.set_axes_locator(InsetPosition(ax1, [0.45, 0.91, 0.45, 0.05]))
    cb1 = ColorbarBase(axpbar, cmap=cmap, norm=cnorm, orientation='horizontal', ticks=[0.0, 0.25, 0.5, 0.75, 1.0])
    cb1.outline.set_edgecolor('w')
    cb1.set_label(r'$\Delta^{op}$ (arb.)', color='w')

    ax2.plot(spectrum[:,0], spectrum[:,1]/np.max(spectrum[:,1]), '-k')

    xs = np.linspace(np.min(l0), np.max(l0), 400)
    norm = w[wi]*np.sqrt(2*np.pi)
    for j in range(npeaks):
        ax2.plot(xs, norm*gauss(xs, w[wi], peak[j][wi,1]-peak[j][wi,2]/2), color='C'+str(j))
        ax2.plot(xs, norm*gauss(xs, w[wi], peak[j][wi,1]+peak[j][wi,2]/2), color='C'+str(j))
        ax2.text(peak[j][wi,1]-peak[j][wi,2]/2, 1.12, r'$\lambda_0 = $' + str(peak[j][wi,1]) + ' nm', color='C'+str(j), ha='left')
        ax2.text(peak[j][wi,1]-peak[j][wi,2]/2, 1.07, r'$\Delta \lambda = $' + str(peak[j][wi,2]) + ' nm', color='C'+str(j), ha='left')
    ax2.text(0.5, 0.95, r'w = '+ str(w[wi]) + ' nm', color='black', ha='center', transform=ax2.transAxes)

    ax2.set_xlim(np.min(l0), np.max(l0))
    ax2.set_ylim(0.0, 1.25)
    ax2.set_xlabel('wavelength (nm)')
    ax2.set_ylabel('spectral irradience (arb.)')

    fig1.show()

    plt.show()
#
